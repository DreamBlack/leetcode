/*题意
你一共有n个硬币，你需要将其摆成阶梯的形状，在这个阶梯中 第 k行 一定要有 k个硬币。

给定一个n，找出可以形成的完整阶梯的总数。

n是一个非负整数，在带符号的32位整数范围内。

注意：
（1）关于数值类型的范围
【笔试题】大部分笔试题主要用到的数据类型为整数类型，这时候double这些具有高位数的便可以 当作辅助工具。
【正常情况】这到题目看似比较简单，我们能够轻易解出 n 为正常值得情况。
【数值类型的范围】32位有符号整数 范围为：  -2^31 ~ 2^31-1（ 2 147 483 647）
【非正常情况 + 难点】你需要考虑当 n 非常接近于32位正整数的最大值得情况，此时你对于n的运算（如：与整数的除法，平方）可能导致数值溢出。举个简单的例子：假如n =1 804 289 383(< 2 147 483 647)， 这意味着 n *2 就会超过32位整数的最大值，进而导致错误（在java中输出结果为：-686388530）。   ---->  所以，在我们的程序中一定得小心对于整数的运算。
【需要注意的运算】 加法 ， 乘法，平方等，这些计算都会使数值增加。
（2）关于二分查找
下面简单说说二分查找的一些特征：

【作用】二分查找基本上每次都会将范围降低为原来的一半。
【适用的场景】二分查找 需要建立在 待查找数值具有次序的基础上。
*/
#include<math.h>

int arrangeCoins(int n) {
	//题目可以理解为找到0.5*(mid+1)*mid<=n，且最大的mid。可使用二分查找
	//之前一直在考虑找到某个mid得到的e比n小，此时e有可能是答案，也有可能不是咋办？其实二分查找会找到那个合适的mid，往左太少，往右太大
	//这是while可以做到的，根本不用担心
	int start = 1, end = n, mid = 0;//start到底从1开始还是从0开始
	while (start <= end) {
		mid = (start + end * 1.0)*0.5;//如果start=1，在n为32位数最大值时，+1会溢出
		double e = 0.5*(mid + 1)*mid;

		if (e <= n) {//等于n时是出口，start也会加一，所以输出要start-1
			start = mid + 1;
		}
		else {
			end = mid - 1;
		}
	}
	return start - 1;
}

int arrangeCoins2(int n) {
	//用数学解方程的思想：题目要求1~x层完整楼梯硬币数量加起来，要小于等于n，求满足的最大x。即(1+x)*x/2 <= n 
	//因式分解得：x <= (sqrt(8*n + 1) - 1) / 2
	//此处要注意不要超过数值范围
	return  (sqrt(8.0*n + 1) - 1) *0.5;

}
int main() {

	return 0;
}
